// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: store_inventory.sql

package db

import (
	"context"
	"database/sql"
)

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO store_inventory (store_id, product_id, quantity) 
VALUES ($1, $2, $3) 
RETURNING inventory_id, store_id, product_id, quantity, last_updated
`

type CreateInventoryItemParams struct {
	StoreID   int32
	ProductID int32
	Quantity  int32
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, createInventoryItem, arg.StoreID, arg.ProductID, arg.Quantity)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :exec
DELETE FROM store_inventory WHERE store_id = $1 AND product_id = $2
`

type DeleteInventoryItemParams struct {
	StoreID   int32
	ProductID int32
}

func (q *Queries) DeleteInventoryItem(ctx context.Context, arg DeleteInventoryItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteInventoryItem, arg.StoreID, arg.ProductID)
	return err
}

const getInventoryByStore = `-- name: GetInventoryByStore :many
SELECT si.inventory_id, si.store_id, si.product_id, si.quantity, si.last_updated,
       p.name as product_name, p.price, p.sku 
FROM store_inventory si
JOIN products p ON si.product_id = p.product_id
WHERE si.store_id = $1
ORDER BY p.name
`

type GetInventoryByStoreRow struct {
	InventoryID int32
	StoreID     int32
	ProductID   int32
	Quantity    int32
	LastUpdated sql.NullTime
	ProductName string
	Price       float64
	Sku         string
}

// Store Inventory queries
func (q *Queries) GetInventoryByStore(ctx context.Context, storeID int32) ([]GetInventoryByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryByStoreRow
	for rows.Next() {
		var i GetInventoryByStoreRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.StoreID,
			&i.ProductID,
			&i.Quantity,
			&i.LastUpdated,
			&i.ProductName,
			&i.Price,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryByStoreAndProduct = `-- name: GetInventoryByStoreAndProduct :one
SELECT inventory_id, store_id, product_id, quantity, last_updated 
FROM store_inventory 
WHERE store_id = $1 AND product_id = $2
`

type GetInventoryByStoreAndProductParams struct {
	StoreID   int32
	ProductID int32
}

func (q *Queries) GetInventoryByStoreAndProduct(ctx context.Context, arg GetInventoryByStoreAndProductParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByStoreAndProduct, arg.StoreID, arg.ProductID)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}

const getProductsAvailableInStore = `-- name: GetProductsAvailableInStore :many
SELECT p.product_id, p.name, p.description, p.price, p.sku, p.category, si.quantity
FROM products p
JOIN store_inventory si ON p.product_id = si.product_id
WHERE si.store_id = $1 AND si.quantity > 0
ORDER BY p.name
`

type GetProductsAvailableInStoreRow struct {
	ProductID   int32
	Name        string
	Description sql.NullString
	Price       float64
	Sku         string
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetProductsAvailableInStore(ctx context.Context, storeID int32) ([]GetProductsAvailableInStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsAvailableInStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsAvailableInStoreRow
	for rows.Next() {
		var i GetProductsAvailableInStoreRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryQuantity = `-- name: UpdateInventoryQuantity :one
UPDATE store_inventory 
SET quantity = $3, last_updated = CURRENT_TIMESTAMP 
WHERE store_id = $1 AND product_id = $2 
RETURNING inventory_id, store_id, product_id, quantity, last_updated
`

type UpdateInventoryQuantityParams struct {
	StoreID   int32
	ProductID int32
	Quantity  int32
}

func (q *Queries) UpdateInventoryQuantity(ctx context.Context, arg UpdateInventoryQuantityParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryQuantity, arg.StoreID, arg.ProductID, arg.Quantity)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}
