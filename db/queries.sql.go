// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO store_inventory (store_id, product_id, quantity) 
VALUES ($1, $2, $3) 
RETURNING inventory_id, store_id, product_id, quantity, last_updated
`

type CreateInventoryItemParams struct {
	StoreID   int32
	ProductID int32
	Quantity  int32
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, createInventoryItem, arg.StoreID, arg.ProductID, arg.Quantity)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (user_id, store_id, total_amount, delivery_address) 
VALUES ($1, $2, $3, $4) 
RETURNING order_id, user_id, store_id, total_amount, status, delivery_address, order_date
`

type CreateOrderParams struct {
	UserID          int32
	StoreID         int32
	TotalAmount     float64
	DeliveryAddress string
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.UserID,
		arg.StoreID,
		arg.TotalAmount,
		arg.DeliveryAddress,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.StoreID,
		&i.TotalAmount,
		&i.Status,
		&i.DeliveryAddress,
		&i.OrderDate,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, quantity, unit_price, total_price) 
VALUES ($1, $2, $3, $4, $5) 
RETURNING order_item_id, order_id, product_id, quantity, unit_price, total_price
`

type CreateOrderItemParams struct {
	OrderID    int32
	ProductID  int32
	Quantity   int32
	UnitPrice  float64
	TotalPrice float64
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name, description, price, sku, category) 
VALUES ($1, $2, $3, $4, $5) 
RETURNING product_id, name, description, price, sku, category, created_at
`

type CreateProductParams struct {
	Name        string
	Description sql.NullString
	Price       float64
	Sku         string
	Category    sql.NullString
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Sku,
		arg.Category,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Sku,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const createStore = `-- name: CreateStore :one
INSERT INTO stores (name, address, phone) 
VALUES ($1, $2, $3) 
RETURNING store_id, name, address, phone, created_at
`

type CreateStoreParams struct {
	Name    string
	Address string
	Phone   sql.NullString
}

func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, createStore, arg.Name, arg.Address, arg.Phone)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, email, phone) 
VALUES ($1, $2, $3) 
RETURNING id, name, email, phone, created_at
`

type CreateUserParams struct {
	Name  string
	Email string
	Phone sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Email, arg.Phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :exec
DELETE FROM store_inventory WHERE store_id = $1 AND product_id = $2
`

type DeleteInventoryItemParams struct {
	StoreID   int32
	ProductID int32
}

func (q *Queries) DeleteInventoryItem(ctx context.Context, arg DeleteInventoryItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteInventoryItem, arg.StoreID, arg.ProductID)
	return err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders WHERE order_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrder, orderID)
	return err
}

const deleteOrderItem = `-- name: DeleteOrderItem :exec
DELETE FROM order_items WHERE order_item_id = $1
`

func (q *Queries) DeleteOrderItem(ctx context.Context, orderItemID int32) error {
	_, err := q.db.ExecContext(ctx, deleteOrderItem, orderItemID)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE product_id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, productID int32) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, productID)
	return err
}

const deleteStore = `-- name: DeleteStore :exec
DELETE FROM stores WHERE store_id = $1
`

func (q *Queries) DeleteStore(ctx context.Context, storeID int32) error {
	_, err := q.db.ExecContext(ctx, deleteStore, storeID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getInventoryByStore = `-- name: GetInventoryByStore :many
SELECT si.inventory_id, si.store_id, si.product_id, si.quantity, si.last_updated,
       p.name as product_name, p.price, p.sku 
FROM store_inventory si
JOIN products p ON si.product_id = p.product_id
WHERE si.store_id = $1
ORDER BY p.name
`

type GetInventoryByStoreRow struct {
	InventoryID int32
	StoreID     int32
	ProductID   int32
	Quantity    int32
	LastUpdated sql.NullTime
	ProductName string
	Price       float64
	Sku         string
}

// Store Inventory queries
func (q *Queries) GetInventoryByStore(ctx context.Context, storeID int32) ([]GetInventoryByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, getInventoryByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInventoryByStoreRow
	for rows.Next() {
		var i GetInventoryByStoreRow
		if err := rows.Scan(
			&i.InventoryID,
			&i.StoreID,
			&i.ProductID,
			&i.Quantity,
			&i.LastUpdated,
			&i.ProductName,
			&i.Price,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryByStoreAndProduct = `-- name: GetInventoryByStoreAndProduct :one
SELECT inventory_id, store_id, product_id, quantity, last_updated 
FROM store_inventory 
WHERE store_id = $1 AND product_id = $2
`

type GetInventoryByStoreAndProductParams struct {
	StoreID   int32
	ProductID int32
}

func (q *Queries) GetInventoryByStoreAndProduct(ctx context.Context, arg GetInventoryByStoreAndProductParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, getInventoryByStoreAndProduct, arg.StoreID, arg.ProductID)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT order_id, user_id, store_id, total_amount, status, delivery_address, order_date 
FROM orders WHERE order_id = $1
`

// Orders queries
func (q *Queries) GetOrderByID(ctx context.Context, orderID int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.StoreID,
		&i.TotalAmount,
		&i.Status,
		&i.DeliveryAddress,
		&i.OrderDate,
	)
	return i, err
}

const getOrderItemsByOrderID = `-- name: GetOrderItemsByOrderID :many
SELECT oi.order_item_id, oi.order_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price,
       p.name as product_name, p.sku
FROM order_items oi
JOIN products p ON oi.product_id = p.product_id
WHERE oi.order_id = $1
ORDER BY oi.order_item_id
`

type GetOrderItemsByOrderIDRow struct {
	OrderItemID int32
	OrderID     int32
	ProductID   int32
	Quantity    int32
	UnitPrice   float64
	TotalPrice  float64
	ProductName string
	Sku         string
}

// Order Items queries
func (q *Queries) GetOrderItemsByOrderID(ctx context.Context, orderID int32) ([]GetOrderItemsByOrderIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderItemsByOrderIDRow
	for rows.Next() {
		var i GetOrderItemsByOrderIDRow
		if err := rows.Scan(
			&i.OrderItemID,
			&i.OrderID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ProductName,
			&i.Sku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT 
    o.order_id, o.user_id, o.store_id, o.total_amount, o.status, o.delivery_address, o.order_date,
    u.name as user_name, u.email as user_email,
    s.name as store_name, s.address as store_address,
    oi.order_item_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price,
    p.name as product_name, p.sku as product_sku
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN stores s ON o.store_id = s.store_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.product_id
WHERE o.order_id = $1
ORDER BY oi.order_item_id
`

type GetOrderWithItemsRow struct {
	OrderID         int32
	UserID          int32
	StoreID         int32
	TotalAmount     float64
	Status          string
	DeliveryAddress string
	OrderDate       sql.NullTime
	UserName        string
	UserEmail       string
	StoreName       string
	StoreAddress    string
	OrderItemID     sql.NullInt32
	ProductID       sql.NullInt32
	Quantity        sql.NullInt32
	UnitPrice       sql.NullString
	TotalPrice      sql.NullString
	ProductName     sql.NullString
	ProductSku      sql.NullString
}

// Complex queries
func (q *Queries) GetOrderWithItems(ctx context.Context, orderID int32) ([]GetOrderWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderWithItemsRow
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.StoreID,
			&i.TotalAmount,
			&i.Status,
			&i.DeliveryAddress,
			&i.OrderDate,
			&i.UserName,
			&i.UserEmail,
			&i.StoreName,
			&i.StoreAddress,
			&i.OrderItemID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ProductName,
			&i.ProductSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT product_id, name, description, price, sku, category, created_at 
FROM products WHERE product_id = $1
`

// Products queries
func (q *Queries) GetProductByID(ctx context.Context, productID int32) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, productID)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Sku,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getProductBySKU = `-- name: GetProductBySKU :one
SELECT product_id, name, description, price, sku, category, created_at 
FROM products WHERE sku = $1
`

func (q *Queries) GetProductBySKU(ctx context.Context, sku string) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductBySKU, sku)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Sku,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const getProductsAvailableInStore = `-- name: GetProductsAvailableInStore :many
SELECT p.product_id, p.name, p.description, p.price, p.sku, p.category, si.quantity
FROM products p
JOIN store_inventory si ON p.product_id = si.product_id
WHERE si.store_id = $1 AND si.quantity > 0
ORDER BY p.name
`

type GetProductsAvailableInStoreRow struct {
	ProductID   int32
	Name        string
	Description sql.NullString
	Price       float64
	Sku         string
	Category    sql.NullString
	Quantity    int32
}

func (q *Queries) GetProductsAvailableInStore(ctx context.Context, storeID int32) ([]GetProductsAvailableInStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsAvailableInStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsAvailableInStoreRow
	for rows.Next() {
		var i GetProductsAvailableInStoreRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT store_id, name, address, phone, created_at FROM stores WHERE store_id = $1
`

// Stores queries
func (q *Queries) GetStoreByID(ctx context.Context, storeID int32) (Store, error) {
	row := q.db.QueryRowContext(ctx, getStoreByID, storeID)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many
SELECT 
    p.product_id, p.name, p.price, p.sku, p.category,
    SUM(oi.quantity) as total_sold,
    COUNT(DISTINCT oi.order_id) as total_orders
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status IN ('confirmed', 'processing', 'shipped', 'delivered')
GROUP BY p.product_id, p.name, p.price, p.sku, p.category
ORDER BY total_sold DESC
LIMIT $1
`

type GetTopSellingProductsRow struct {
	ProductID   int32
	Name        string
	Price       float64
	Sku         string
	Category    sql.NullString
	TotalSold   int64
	TotalOrders int64
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, limit int32) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingProducts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.TotalSold,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, phone, created_at FROM users WHERE id = $1
`

// Users queries
func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const getUserOrderSummary = `-- name: GetUserOrderSummary :many
SELECT 
    u.id as user_id, u.name, u.email,
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name, u.email
ORDER BY total_spent DESC NULLS LAST
`

type GetUserOrderSummaryRow struct {
	UserID        int32
	Name          string
	Email         string
	TotalOrders   int64
	TotalSpent    int64
	LastOrderDate interface{}
}

func (q *Queries) GetUserOrderSummary(ctx context.Context) ([]GetUserOrderSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrderSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrderSummaryRow
	for rows.Next() {
		var i GetUserOrderSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.TotalOrders,
			&i.TotalSpent,
			&i.LastOrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByStore = `-- name: ListOrdersByStore :many
SELECT o.order_id, o.user_id, o.store_id, o.total_amount, o.status, o.delivery_address, o.order_date,
       u.name as user_name, u.email as user_email
FROM orders o
JOIN users u ON o.user_id = u.id
WHERE o.store_id = $1 
ORDER BY o.order_date DESC
`

type ListOrdersByStoreRow struct {
	OrderID         int32
	UserID          int32
	StoreID         int32
	TotalAmount     float64
	Status          string
	DeliveryAddress string
	OrderDate       sql.NullTime
	UserName        string
	UserEmail       string
}

func (q *Queries) ListOrdersByStore(ctx context.Context, storeID int32) ([]ListOrdersByStoreRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByStoreRow
	for rows.Next() {
		var i ListOrdersByStoreRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.StoreID,
			&i.TotalAmount,
			&i.Status,
			&i.DeliveryAddress,
			&i.OrderDate,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT o.order_id, o.user_id, o.store_id, o.total_amount, o.status, o.delivery_address, o.order_date,
       s.name as store_name
FROM orders o
JOIN stores s ON o.store_id = s.store_id
WHERE o.user_id = $1 
ORDER BY o.order_date DESC
`

type ListOrdersByUserRow struct {
	OrderID         int32
	UserID          int32
	StoreID         int32
	TotalAmount     float64
	Status          string
	DeliveryAddress string
	OrderDate       sql.NullTime
	StoreName       string
}

func (q *Queries) ListOrdersByUser(ctx context.Context, userID int32) ([]ListOrdersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByUserRow
	for rows.Next() {
		var i ListOrdersByUserRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.StoreID,
			&i.TotalAmount,
			&i.Status,
			&i.DeliveryAddress,
			&i.OrderDate,
			&i.StoreName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT product_id, name, description, price, sku, category, created_at 
FROM products 
ORDER BY created_at DESC
`

func (q *Queries) ListProducts(ctx context.Context) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT product_id, name, description, price, sku, category, created_at 
FROM products 
WHERE category = $1 
ORDER BY name
`

func (q *Queries) ListProductsByCategory(ctx context.Context, category sql.NullString) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStores = `-- name: ListStores :many
SELECT store_id, name, address, phone, created_at FROM stores 
ORDER BY created_at DESC
`

func (q *Queries) ListStores(ctx context.Context) ([]Store, error) {
	rows, err := q.db.QueryContext(ctx, listStores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Store
	for rows.Next() {
		var i Store
		if err := rows.Scan(
			&i.StoreID,
			&i.Name,
			&i.Address,
			&i.Phone,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, phone, created_at FROM users 
ORDER BY created_at DESC
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryQuantity = `-- name: UpdateInventoryQuantity :one
UPDATE store_inventory 
SET quantity = $3, last_updated = CURRENT_TIMESTAMP 
WHERE store_id = $1 AND product_id = $2 
RETURNING inventory_id, store_id, product_id, quantity, last_updated
`

type UpdateInventoryQuantityParams struct {
	StoreID   int32
	ProductID int32
	Quantity  int32
}

func (q *Queries) UpdateInventoryQuantity(ctx context.Context, arg UpdateInventoryQuantityParams) (StoreInventory, error) {
	row := q.db.QueryRowContext(ctx, updateInventoryQuantity, arg.StoreID, arg.ProductID, arg.Quantity)
	var i StoreInventory
	err := row.Scan(
		&i.InventoryID,
		&i.StoreID,
		&i.ProductID,
		&i.Quantity,
		&i.LastUpdated,
	)
	return i, err
}

const updateOrderItem = `-- name: UpdateOrderItem :one
UPDATE order_items 
SET quantity = $3, unit_price = $4, total_price = $5 
WHERE order_item_id = $1 AND order_id = $2 
RETURNING order_item_id, order_id, product_id, quantity, unit_price, total_price
`

type UpdateOrderItemParams struct {
	OrderItemID int32
	OrderID     int32
	Quantity    int32
	UnitPrice   float64
	TotalPrice  float64
}

func (q *Queries) UpdateOrderItem(ctx context.Context, arg UpdateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, updateOrderItem,
		arg.OrderItemID,
		arg.OrderID,
		arg.Quantity,
		arg.UnitPrice,
		arg.TotalPrice,
	)
	var i OrderItem
	err := row.Scan(
		&i.OrderItemID,
		&i.OrderID,
		&i.ProductID,
		&i.Quantity,
		&i.UnitPrice,
		&i.TotalPrice,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders 
SET status = $2 
WHERE order_id = $1 
RETURNING order_id, user_id, store_id, total_amount, status, delivery_address, order_date
`

type UpdateOrderStatusParams struct {
	OrderID int32
	Status  string
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.OrderID, arg.Status)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.UserID,
		&i.StoreID,
		&i.TotalAmount,
		&i.Status,
		&i.DeliveryAddress,
		&i.OrderDate,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products 
SET name = $2, description = $3, price = $4, category = $5 
WHERE product_id = $1 
RETURNING product_id, name, description, price, sku, category, created_at
`

type UpdateProductParams struct {
	ProductID   int32
	Name        string
	Description sql.NullString
	Price       float64
	Category    sql.NullString
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ProductID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Category,
	)
	var i Product
	err := row.Scan(
		&i.ProductID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Sku,
		&i.Category,
		&i.CreatedAt,
	)
	return i, err
}

const updateStore = `-- name: UpdateStore :one
UPDATE stores 
SET name = $2, address = $3, phone = $4 
WHERE store_id = $1 
RETURNING store_id, name, address, phone, created_at
`

type UpdateStoreParams struct {
	StoreID int32
	Name    string
	Address string
	Phone   sql.NullString
}

func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) (Store, error) {
	row := q.db.QueryRowContext(ctx, updateStore,
		arg.StoreID,
		arg.Name,
		arg.Address,
		arg.Phone,
	)
	var i Store
	err := row.Scan(
		&i.StoreID,
		&i.Name,
		&i.Address,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users 
SET name = $2, email = $3, phone = $4 
WHERE id = $1 
RETURNING id, name, email, phone, created_at
`

type UpdateUserParams struct {
	ID    int32
	Name  string
	Email string
	Phone sql.NullString
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Phone,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}
