// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: complex.sql

package db

import (
	"context"
	"database/sql"
)

const getOrderWithItems = `-- name: GetOrderWithItems :many
SELECT 
    o.order_id, o.user_id, o.store_id, o.total_amount, o.status, o.delivery_address, o.order_date,
    u.name as user_name, u.email as user_email,
    s.name as store_name, s.address as store_address,
    oi.order_item_id, oi.product_id, oi.quantity, oi.unit_price, oi.total_price,
    p.name as product_name, p.sku as product_sku
FROM orders o
JOIN users u ON o.user_id = u.id
JOIN stores s ON o.store_id = s.store_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
LEFT JOIN products p ON oi.product_id = p.product_id
WHERE o.order_id = $1
ORDER BY oi.order_item_id
`

type GetOrderWithItemsRow struct {
	OrderID         int32
	UserID          int32
	StoreID         int32
	TotalAmount     float64
	Status          string
	DeliveryAddress string
	OrderDate       sql.NullTime
	UserName        string
	UserEmail       string
	StoreName       string
	StoreAddress    string
	OrderItemID     sql.NullInt32
	ProductID       sql.NullInt32
	Quantity        sql.NullInt32
	UnitPrice       sql.NullString
	TotalPrice      sql.NullString
	ProductName     sql.NullString
	ProductSku      sql.NullString
}

// Complex queries
func (q *Queries) GetOrderWithItems(ctx context.Context, orderID int32) ([]GetOrderWithItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getOrderWithItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderWithItemsRow
	for rows.Next() {
		var i GetOrderWithItemsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.StoreID,
			&i.TotalAmount,
			&i.Status,
			&i.DeliveryAddress,
			&i.OrderDate,
			&i.UserName,
			&i.UserEmail,
			&i.StoreName,
			&i.StoreAddress,
			&i.OrderItemID,
			&i.ProductID,
			&i.Quantity,
			&i.UnitPrice,
			&i.TotalPrice,
			&i.ProductName,
			&i.ProductSku,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many
SELECT 
    p.product_id, p.name, p.price, p.sku, p.category,
    SUM(oi.quantity) as total_sold,
    COUNT(DISTINCT oi.order_id) as total_orders
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE o.status IN ('confirmed', 'processing', 'shipped', 'delivered')
GROUP BY p.product_id, p.name, p.price, p.sku, p.category
ORDER BY total_sold DESC
LIMIT $1
`

type GetTopSellingProductsRow struct {
	ProductID   int32
	Name        string
	Price       float64
	Sku         string
	Category    sql.NullString
	TotalSold   int64
	TotalOrders int64
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, limit int32) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingProducts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Name,
			&i.Price,
			&i.Sku,
			&i.Category,
			&i.TotalSold,
			&i.TotalOrders,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserOrderSummary = `-- name: GetUserOrderSummary :many
SELECT 
    u.id as user_id, u.name, u.email,
    COUNT(o.order_id) as total_orders,
    SUM(o.total_amount) as total_spent,
    MAX(o.order_date) as last_order_date
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name, u.email
ORDER BY total_spent DESC NULLS LAST
`

type GetUserOrderSummaryRow struct {
	UserID        int32
	Name          string
	Email         string
	TotalOrders   int64
	TotalSpent    int64
	LastOrderDate interface{}
}

func (q *Queries) GetUserOrderSummary(ctx context.Context) ([]GetUserOrderSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserOrderSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserOrderSummaryRow
	for rows.Next() {
		var i GetUserOrderSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.Email,
			&i.TotalOrders,
			&i.TotalSpent,
			&i.LastOrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
